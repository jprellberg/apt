/*-
 * APT - Analysis of Petri Nets and labeled Transition systems
 * Copyright (C) 2016 Jonas Prellberg
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package uniol.apt.analysis.sequences;

import java.util.Collections;
import java.util.List;
import java.util.Objects;

import uniol.apt.adt.ts.Arc;
import uniol.apt.util.Pair;

/**
 * Represents a binary subsequence in a LTS in the form of a regular expression
 * vw* where |v| ≠ 0 or |w| ≠ 0.
 *
 * @author Jonas Prellberg
 */
public class BinarySeqExpression {

	/**
	 * Constructs a new {@link BinarySeqExpression} with the given v and |w|
	 * = 0.
	 *
	 * @param v
	 *                path
	 * @return PathExpression of v
	 */
	public static BinarySeqExpression v(List<Arc> v) {
		List<Arc> w = Collections.emptyList();
		return new BinarySeqExpression(v, w);
	}

	/**
	 * Constructs a new {@link BinarySeqExpression} with the given w and |v|
	 * = 0.
	 *
	 * @param w
	 *                cycle
	 * @return PathExpression of w*
	 */
	public static BinarySeqExpression w(List<Arc> w) {
		List<Arc> v = Collections.emptyList();
		return new BinarySeqExpression(v, w);
	}

	/**
	 * Constructs a new {@link BinarySeqExpression} with the given v and w.
	 * Note that v and w must use the same alphabet or incorrect results may
	 * be returned.
	 *
	 * @param v
	 *                path
	 * @param w
	 *                cycle
	 * @return PathExpression of vw*
	 */
	public static BinarySeqExpression vw(List<Arc> v, List<Arc> w) {
		return new BinarySeqExpression(v, w);
	}

	/**
	 * Constructs a new {@link BinarySeqExpression} with |v| = 0 and |w| =
	 * 0.
	 *
	 * @return empty PathExpression
	 */
	public static BinarySeqExpression empty() {
		List<Arc> v = Collections.emptyList();
		List<Arc> w = Collections.emptyList();
		return new BinarySeqExpression(v, w);
	}

	private final List<Arc> v;
	private final List<Arc> w;

	private BinarySeqExpression(List<Arc> v, List<Arc> w) {
		this.v = v;
		this.w = w;
	}

	/**
	 * @return the arcs that make up the path v
	 */
	public List<Arc> getV() {
		return v;
	}

	/**
	 * @return the arcs that make up the cycle w
	 */
	public List<Arc> getW() {
		return w;
	}

	/**
	 * @return true if |v| = 0 and |w| = 0
	 */
	public boolean isEmpty() {
		return v.isEmpty() && w.isEmpty();
	}

	/**
	 * @return true if |v| < 2 and |w| = 0
	 */
	public boolean isEmptyOrSingleLetterWord() {
		return v.size() < 2 && w.isEmpty();
	}

	/**
	 * Returns a string that contains states and arcs of the path
	 * expression. If the cycle part is not empty the cycle entry state will
	 * be marked.
	 *
	 * @return the generated string
	 */
	public String toStateArcString() {
		if (isEmpty()) {
			return "";
		}

		StringBuilder sb = new StringBuilder();
		for (Arc arc : v) {
			sb.append(arcToSourceLabelString(arc));
		}
		if (w.isEmpty()) {
			Arc last = v.get(v.size() - 1);
			sb.append(last.getTargetId());
		} else {
			sb.append("*");
		}
		for (Arc arc : w) {
			sb.append(arcToSourceLabelString(arc));
		}
		if (!w.isEmpty()) {
			Arc last = w.get(w.size() - 1);
			sb.append(last.getTargetId());
		}
		return sb.toString();
	}

	private String arcToSourceLabelString(Arc arc) {
		return arc.getSourceId() + " --" + arc.getLabel() + "-> ";
	}

	/**
	 * Returns a string that is a regular expression of the form v(w)*.
	 *
	 * @return regular expression string
	 */
	public String toRegExpString() {
		return toRegExpString(null, null);
	}

	/**
	 * Returns a string that is a regular expression of the form v(w)* with
	 * labels normalized to a and b.
	 *
	 * @return regular expression string
	 */
	public String toRegExpString(String a, String b) {
		Pair<String, String> vw = arcListsToString(v, w, a, b);
		StringBuilder sb = new StringBuilder();
		sb.append(vw.getFirst());
		if (!w.isEmpty()) {
			sb.append("(");
			sb.append(vw.getSecond());
			sb.append(")*");
		}
		return sb.toString();
	}

	/**
	 * Returns a word that is generated by this path expression vw*. If the
	 * cycle part of this sequence (w) is not empty it will be unrolled the
	 * given number of times.
	 *
	 * @param unrollDepth
	 *                times to unroll w
	 * @return the generated word
	 */
	public String toWord(int unrollDepth) {
		return toWord(null, null, unrollDepth);
	}

	/**
	 * Returns a word that is generated by this path expression vw* with
	 * labels normalized to a and b. If the cycle part of this sequence (w)
	 * is not empty it will be unrolled the given number of times.
	 *
	 * @param a
	 *                first label
	 * @param b
	 *                second label
	 * @param unrollDepth
	 *                times to unroll w
	 * @return the generated word
	 */
	public String toWord(String a, String b, int unrollDepth) {
		Pair<String, String> vw = arcListsToString(v, w, a, b);
		StringBuilder sb = new StringBuilder();
		sb.append(vw.getFirst());
		for (int i = 0; i < unrollDepth; i++) {
			sb.append(vw.getSecond());
		}
		return sb.toString();
	}

	private Pair<String, String> arcListsToString(List<Arc> arcs1, List<Arc> arcs2, String a, String b) {
		String originalA = null;
		String originalB = null;

		StringBuilder sb1 = new StringBuilder();
		for (Arc arc : arcs1) {
			String originalLabel = arc.getLabel();
			if (a == null || b == null) {
				sb1.append(originalLabel);
			} else if (originalLabel.equals(originalA)) {
				sb1.append(a);
			} else if (originalLabel.equals(originalB)) {
				sb1.append(b);
			} else if (originalA == null) {
				originalA = originalLabel;
				sb1.append(a);
			} else if (originalB == null) {
				originalB = originalLabel;
				sb1.append(b);
			}
		}

		// Ugly duplication...
		StringBuilder sb2 = new StringBuilder();
		for (Arc arc : arcs2) {
			String originalLabel = arc.getLabel();
			if (a == null || b == null) {
				sb2.append(originalLabel);
			} else if (originalLabel.equals(originalA)) {
				sb2.append(a);
			} else if (originalLabel.equals(originalB)) {
				sb2.append(b);
			} else if (originalA == null) {
				originalA = originalLabel;
				sb2.append(a);
			} else if (originalB == null) {
				originalB = originalLabel;
				sb2.append(b);
			}

		}

		return new Pair<>(sb1.toString(), sb2.toString());
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((v == null) ? 0 : v.hashCode());
		result = prime * result + ((w == null) ? 0 : w.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		BinarySeqExpression other = (BinarySeqExpression) obj;
		return Objects.equals(v, other.v) && Objects.equals(w, other.w);
	}

	@Override
	public String toString() {
		return toStateArcString();
	}

}
// vim: ft=java:noet:sw=8:sts=8:ts=8:tw=120
